package lib

import (
	"bytes"
	"fmt"
	"github.com/Masterminds/sprig/v3"
	"github.com/iancoleman/strcase"
	"github.com/rs/zerolog/log"
	"go/format"
	"html/template"
	"os"
	"path"
	"reflect"
	"sort"
	"strings"
	"unicode"
)

const Template = `// Code generated by ogen-postgen, DO NOT EDIT.

package {{ .PackageName }}

{{ $data := .}}

{{- if .Imports }}
import (
	{{- range .Imports }}
	{{ if .Alias }}{{ .Alias}} {{ end }}"{{.PackagePath}}"
	{{- end }}
)
{{- end }}


{{- range .InterFaces }}
type {{ .InterfaceName }} interface {
  {{- range .Methods }}
  {{ .MethodName }}({{ .Params }}) ({{ .Returns }})
  {{- end }}
}
{{- end }}

{{- range .InterFaces }}
type {{ lowerCamelcase .InterfaceName }}Server struct{
	UnimplementedHandler
    h {{ .InterfaceName }}
	{{ if $data.ErrorHandler }} e NewErrorFunc {{ end }}
}
{{- end }}

{{- range $i, $a := .InterFaces }}
{{- range .Methods }}
func (i {{ lowerCamelcase $a.InterfaceName }}Server) {{ .MethodName }}( {{ .Params }} ) ({{ .Returns}}) {
	return i.h.{{ .MethodName }}({{ .ParamsWithoutTypes }})
}
{{- end }}

{{ if $data.ErrorHandler }}
func (i {{ lowerCamelcase $a.InterfaceName }}Server) NewError({{ $data.ErrorHandler.Params }}) ({{ $data.ErrorHandler.Returns }}) {
	return i.e( {{ $data.ErrorHandler.ParamsWithoutTypes }} )
}
{{ end }}

{{- end }}


{{ if $data.ErrorHandler }}
type NewErrorFunc func({{ $data.ErrorHandler.Params }}) ({{ $data.ErrorHandler.Returns }})
{{ end }}



{{- range .InterFaces }}
{{ if $data.ErrorHandler }}
func New{{ .InterfaceName }}Server(i {{ .InterfaceName }}, errorHandler NewErrorFunc, opts ...ServerOption) (*Server, error){
	handler:= {{ lowerCamelcase .InterfaceName }}Server{
		UnimplementedHandler: UnimplementedHandler{},
		h : i,
		e : errorHandler,
	}
	return NewServer(handler,opts...)
}
{{ else }}
func New{{ .InterfaceName }}Server(i {{ .InterfaceName }}, opts ...ServerOption) (*Server, error){
	handler:= {{ lowerCamelcase .InterfaceName }}Server{
		UnimplementedHandler: UnimplementedHandler{},
		h : i,
	}
	return NewServer(handler,opts...)
}
{{ end }}

{{- end }}


type mergedService struct {
	e NewErrorFunc
	{{- range $i, $a := .InterFaces }}
	s{{ $i }} {{$a.InterfaceName }}
	{{- end }}
}
func NewMergedService({{ if $data.ErrorHandler }} errorHandler NewErrorFunc {{ end }}, {{- range $i, $a := .InterFaces }} 
s{{ $i }} {{$a.InterfaceName }}, 
{{- end }} ) Handler {
	return &mergedService{
		{{ if $data.ErrorHandler }} e : errorHandler{{ end }},
		{{- range $i, $a := .InterFaces }}
		s{{ $i }} : s{{ $i }},
		{{- end }}
	}
}

{{- range $i, $a := .InterFaces }}
{{- range .Methods }}
func (s mergedService) {{ .MethodName }}( {{ .Params }} ) ({{ .Returns}}) {
	return s.s{{ $i }}.{{ .MethodName }}({{ .ParamsWithoutTypes }})
}
{{- end }}
{{- end }}

{{ if $data.ErrorHandler }}
func (i mergedService) NewError({{ $data.ErrorHandler.Params }}) ({{ $data.ErrorHandler.Returns }}) {
	return i.e( {{ $data.ErrorHandler.ParamsWithoutTypes }} )
}
{{ end }}

`

type slice []SeparatedInterface

func (s slice) Len() int {
	return len(s)
}

func (s slice) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

func (s slice) Less(d, e int) bool {
	t := strings.Map(unicode.ToUpper, s[d].InterfaceName)
	u := strings.Map(unicode.ToUpper, s[e].InterfaceName)
	return t < u
}

func Generate(writeTo string, genInfo *GenInfo, packageName string) error {
	sortingSlice := slice(genInfo.InterFaces)
	sort.Sort(sortingSlice)
	genInfo.InterFaces = sortingSlice
	_, fileName := path.Split(writeTo)
	tmp := template.Must(template.New(fileName).
		Funcs(getFuncMap()).
		Parse(Template))
	var genStruct = struct {
		*GenInfo
		PackageName string
	}{
		GenInfo:     genInfo,
		PackageName: packageName,
	}
	buf := new(bytes.Buffer)
	if err := tmp.Execute(buf, genStruct); err != nil {
		log.Err(err).Msg("execute template fails")
		return fmt.Errorf("execute template")
	}
	file, err := os.Create(writeTo)
	if err != nil {
		return fmt.Errorf("create file: %w", err)
	}
	defer func(file *os.File) {
		_ = file.Close()
	}(file)
	content, err := format.Source(buf.Bytes())
	_, err = file.Write(content)
	if err != nil {
		return fmt.Errorf("write file")
	}
	return nil
}

// getFuncMap provides a template function map
func getFuncMap() template.FuncMap {
	// See http://masterminds.github.io/sprig/ for available funcs
	funcMap := sprig.FuncMap()

	// Provide a list of custom functions
	// Expand this as you add more functions to this package
	// Avoid using a name already in use by sprig
	f := template.FuncMap{
		"hasField":       hasField,
		"lowerCamelcase": strcase.ToLowerCamel,
	}

	for k, v := range f {
		funcMap[k] = v
	}

	return funcMap
}

// HasField checks if an interface contains a given field
func hasField(v interface{}, name string) bool {
	rv := reflect.ValueOf(v)
	if rv.Kind() == reflect.Ptr {
		rv = rv.Elem()
	}
	if rv.Kind() != reflect.Struct {
		return false
	}
	return rv.FieldByName(name).IsValid()
}
